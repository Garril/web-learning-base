/* toFixed 的坑 
  为了闭坑可以使用库 Decimal.js 
    =》 原理：存字符串，运算是字符串运算
*/
2.45.toFixed(1)  // 2.5
2.45.toFixed(2)  // 2.45
2.55.toFixed(1)  // 2.5


// 这个坑存在的原因是什么？
/*
  先引入：
  控制台：
  0.1 + 0.2 = 0.300000000..00004

  0.2.toString(2) -> 0.00110011 00110011 ..... 001101
  0.2.toPrecision(20) -> 转为10进制，20位 --> 0.2000000.....001110

  因为0.2他的二进制是一个无限循环小数，到一定位数后会截取，最后进位

  你会发现 
  0.2000...0000...0001.toString(2)
  和
  0.1999...9999...9999.toString(2)
  一样
  0.2000...0000...0001 === 0.1999...9999...9999 是true

  有些数字就不会有无限循环小数
  比如：0.25.toString(2) -> 0.01



  ----- 由上可以知道，计算机的存储不精确
  又因为是用二进制去计算的，那么计算也不精确
  那为什么：0.2+0.3 = 0.5是精确的？
  二进制0.2和 0.3小数都是有进行舍去或者进位的情况的。
  原因是：这两个的误差，刚刚好弥补了。
  
  二进制里，0.3舍去部分，偏小，0.2入了一位，偏大
  具体可以看：
  0.3 - 0.2 = 0.09999999...998

  
  那么为什么显示的十进制有时候是对的？
  var a = 0.2;
  a // 0.2
  因为浏览器显示的时候做了近似处理，他发现0.2的二进制很像0.2。
  显示的时候也是不精确，精确应该是显示 0.2000000....
  
  像0.1+0.2 = 0.30000000.....4
  他觉得误差太大了，不像0.3，就不敢做处理。

  具体可以通过 toPrecision 去查看。
*/

/* 
  toFixed 是先运算再显示
  通过上述的引入我们知道，运算和显示其实都是不准确的
  
  2.45.toFixed(1)
  可以认为他的步骤为：2.45.toPrecision(100) ==> 2.4500000017763..........
  然后 四舍五入，再截取拿到 2.5

  同理你看
  2.55.toFixed(1)
  2.55.toPrecision(100) ==> 2.54999..........
  结果为 2.5
*/
