# event_loop/message_loop

事件循环/消息循环，两个叫法而已。

## 浏览器进程模型

### 前置简介

#### 进程

每个应用至少一个进程（分得内存），相互独立，如果通信，需要双方同意。

#### 线程

进程中至少有一个线程（主线程结束则进程结束）

<hr/>
### 浏览器

（这里只说三个）三进程： 浏览器进程、网络进程、渲染进程

#### 浏览器进程（主进程）

负责浏览器界面展示、用户交互、子进程管理等（注意区分界面和页面）

#### 网络进程

网络资源加载

#### 渲染进程\*

一个标签页一个渲染进程，保证互不影响，负责执行 html、css、js。
（之后可能一个站点开一个渲染进程，目前仍然为 process-per-tab）。

时间循环发生在 渲染进程的 渲染主线程 中 负责执行 html、css、js。
还有交互线程，计时线程等。

<hr/>

### 渲染主线程如何工作

首先他需要处理：解析 HTML、CSS，计算样式，布局，处理图层，1s 画页面 60 次（FPS），执行全局 js，执行事件处理函数，执行计时器的回调函数等。

#### js 的异步

首先 js 是单线程，运行在渲染进程的渲染主线程里，主线程，进程中唯一。而主线程又有很多事情要干，比如渲染页面、执行 js，解析 html、css，执行计数器回调等，同步那就阻塞，那页面容易卡死。

异步的话，主线程遇到某些任务，比如计时器，网络，事件监听，直接交给其他线程去处理，成了后将传入的回调包装为任务，丢到 message queue 末尾去排队，而主线程自身立即结束该特殊任务的执行，转而执行后续代码。保证了单线程的流程运行。

#### 任务有优先级吗？消息队列呢？

任务无优先级，但是消息队列有优先级。

随着浏览器的复杂度提升，w3c 不再使用宏任务的说法。

新说法：每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列，在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。
但是浏览器必须准备好一个微队列。

https://html.spec.whatwg.org/multipage/webappapis.html
8.1.7.3 Processing model

目前 chorme（优先级浏览器自行决定），至少包含下面队列，优先级从高到低为：微队列 > 交互队列 > 延时队列。

#### JS 的计时器能够做到精确计时吗？为什么？

不行，受事件循环的影响，计时器的回调只能在主线程空闲时运行，带来了偏差。
（了解即可：
1、因为计算机硬件没有原子钟，用的 CPU 寄存器做的，无法做到精确计时。
2、操作系统计时本身就有少量偏差，js 的计时器最终调用的是操作系统的函数，有偏差。
3、按照 w3c 的标准，浏览器使用计时器，如果嵌套层超过 5 层，则内层会有至少 4 毫秒的延迟时间。）
