## 1、Http 1.0和2.0的区别

```css
与 HTTP 1.1对比的区别？
    1、HTTP/2采用二进制格式而非文本格式 （二进制格式）
    2、HTTP/2是完全多路复用的，而非有序并阻塞的——只需一个连接即可实现并行 （多路复用且非有序）
    3、使用报头压缩，HTTP/2降低了开销 （压缩报文头）
    4、HTTP/2让服务器可以将响应主动“推送”到客户端缓存中 （服务器主动推送）

HTTP 2为什么是二进制？
	二进制协议解析起来更高效，错误更少。
```



### 为什么 HTTP/2 需要多路传输?

```css
为什么 HTTP/2 需要多路传输?
	HTTP/1.x 有个问题叫线端阻塞(head-of-line blocking), 
	它是指一个连接(connection)一次只提交一个请求的效率比较高, 多了就会变慢。
	HTTP/1.1 试过用流水线(pipelining)来解决这个问题, 
	但是效果并不理想(数据量较大或者速度较慢的响应, 会阻碍排在他后面的请求). 
	而多路传输(Multiplexing)能很好的解决这些问题, 因为它能同时处理多个消息的请求和响应; 
	甚至可以在传输过程中将一个消息跟另外一个掺杂在一起。
	所以客户端只需要一个连接就能加载一个页面。
	(总结：HTTP1.x线端阻塞，一个连接，接收的请求多了慢，而HTTP2可以同时处理多个请求和响应)
```



### 消息头为什么需要压缩?

```css
消息头为什么需要压缩?
	假定一个页面有80个资源需要加载（这个数量对于今天的Web而言还是挺保守的）, 
	而每一次请求都有1400字节的消息头（着同样也并不少见，因为Cookie和引用等东西的存在）, 
	至少要7到8个来回去“在线”获得这些消息头。
	这还不包括响应时间——那只是从客户端那里获取到它们所花的时间而已。
	这全都由于TCP的慢启动机制，它会基于对已知有多少个包，来确定还要来回去获取哪些包 
	–- 这很明显的限制了最初的几个来回可以发送的数据包的数量。
	相比之下，即使是头部轻微的压缩，也可以让那些请求只需一个来回就能搞定
	-- 有时候甚至一个包就可以了。
	这种开销是可以被节省下来的，特别是当你考虑移动客户端应用的时候，
	即使是良好条件下，一般也会看到几百毫秒的来回延迟。
```



### 服务器推送的好处是什么？

```css
服务器推送的好处是什么？
	当浏览器请求一个网页时，服务器将会发回HTML，
	在服务器开始发送JavaScript、图片和CSS请求前，
	服务器需要等待浏览器解析HTML和发送所有内嵌资源的请求。
	服务器推送服务通过“推送”那些它认为客户端将会需要的内容到客户端的缓存中，
	以此来避免往返的延迟。
```



## 2、全双工半双工与单工

```css
1、单工
	在单工模式下，通信是单向的，即数据流向一个方向。
	设备只能发送数据而不能接收数据，或者可以接收数据但不能发送数据。
	比如：广播电台是一个单工频道，它将信号传输给听众，但从不允许他们回传。
	优点：可以利用通信信道的整个带宽，所以一次性可以传输更多的数据

2、半双工
	半双工允许双向通信，但不能同时进行，信号在介质上双向传播，
	但一次只能向一个方向传播，由于信号仅沿一个方向传播，
	因此设备可以在给定时间发送或接收数据，设置为半双工的网卡在发送数据时无法接收数据。
	比如：对讲机
	优点：半双工在同一时刻也是占用整条带宽，所以每次也能传输很多数据。

3、全双工
	全双工允许同时在两个方向上进行通信，它将可用通道分为两部分，
	一部分用于发送数据，另一部分用于接收数据。
	优点：通信双方可以同时发送和接收数据，效率很高。
	缺点：假如设备之间不存在专用路径，那么信道容量就会减少一半（其他路堵了，都走同一条了）

如果问Http如何实现全双工？
	可以回答，因为浏览器拿到Ip后，是先去TCP三次握手建立连接，
	然后再去发送http请求的，而TCP是全双工协议
```



## 3、TCP、UDP、Http

### TCP和UDP

```css
TCP：
    是用来实现通信的，它是一个全双工的协议(后面会说明)。
    在IP实现了网络间路径后，TCP提供了这个路径的全双工通信的能力。
    这个链接的建立要经历三次握手，断开链接要四次挥手。

UDP:
    是和TCP相似的，也是提供了通信能力。不过和TCP有区别。
    TCP是点对点的通讯，UDP支持一对多，多对一，一对一等。
    UDP不需要链接，直接发数据，相对来说速度更快，但是不保证数据一定会到达，适合广播。
```



### TCP三次握手

```css
TCP三次握手：
	（ Tcp协议为了方便传输报文，会把发送的请求报文拆分成小的报文段进行管理，
	 并把它们编号，为了服务器能准确具体的还原返回报文信息 ）
	以下例子中A为客户端，B为服务器，来说明三次握手与四次挥手过程。

    第一次握手: 
		客户端A发送SYN=1（代表要向B建立连接）,
		seq=a（A发送数据的一个序列号）到服务器。
    第二次握手：
		服务器B收到数据后，向客户端A发送ACK=1（代表应答收到）,
		SYN=1（代表要向A建立连接）,
		seq=b（B发送数据的一个序列号），
		ack=a+1(等于收到数据时候的seq+1，代表确认码)。
    第三次握手：
		客户端A收到数据后先看下ack是不是上次发的seq+1=a+1。
		确保没问题后会向服务器B发送ACK=1（代表应答收到），
		seq=a+1（A发送数据的下一个序列号），
		ack=b+1（等于收到数据时候的seq+1，代表确认码）。
	总结：
		ACK用于确认是否收到 （客户端服务端）
		SYN表示确认要客户端建立连接 （服务端）
		seq表示数据的序列号 （客户端服务端）
		ack表示确认码，等于客户/服务端接收到的seq+1 （客户端服务端）---防止被超时的包影响
```



### TCP四次挥手

```css
第一次挥手：
	客户端A向服务器B发送
	FIN=1(A请求断开服务器连接),seq=a(本次数据序列号)。
第二次挥手：
	服务器B向客户端A发送
	ACK=1(应答，收到数据)seq=a+1(代表还有数据没发送)。
第三次挥手：
	服务器向客户端A发送
	FIN=1（服务器要断开A的链接）,seq=b(本次数据的序列号)，
	ack=a+1（确认码，代表没有数据要发送了）。
第四次挥手：
	客户端A验证收到的ack是不是等于a+1，
	确保B没有数据在发送了。
	然后发送给服务器B，
	ACK(应答),seq=b+1(本次数据序列号)。
总结：
    FIN用于请求/确认断开连接 （客户端服务端）
    ACK用于确认是否收到 （客户端服务端）
    seq表示数据的序列号 （客户端服务端）
    ack表示确认码，等于服务端接收到的seq+1 （服务端）---防止被超时的包影响
```



### Http协议

```css
http是应用层的协议，它实现了怎么发数据和怎么收数据，定义了收发的格式，
同时定义了是短连接。当一次传输数据结束就断开链接。

http1.0是个短连接，当一次链接数据传送完毕后，就会断开链接。
http1.1前端和后台可以配置成长链接，默认60s，当一次链接成功，发送完一次数据后，60s内如果前端再一次请求数据那么将复用上一次tcp通道，并且倒计时重新刷新。当60s结束后客户端没进行请求数据，这时候tcp就会断开链接。这个倒计时时间是支持设置的。
```



### Http请求

```css
Http请求为3部分：请求行、请求头、请求体

请求行
    说明了是get方法，还是post方法等等，说明了协议版本http 1.1等，
	get方法会有URL。这里get方法参数往往要求ASCII码，也就是不能有中文，并且还有长度限制，
	post没有。其实这里往往是浏览器等作出的限制，而不是post的请求行中就不能放参数。

请求头
	包含了User-Agent：浏览器类型，请求数据的来源。
	Accept：可以接收的数据类型，这里要和服务器的Content-Type匹配。
	服务器发送的类型和客户端可以接收的类型要一致。
	Accept-Encoding，Accept-Language等等。
	Content-Type:发送内容的类型，往往post方法才会有，因为post方法的参数是在请求体里。
	请求头部也可以自己添加新字段，比如常见的添加token，userId等。

请求体
	一般只有post方法请求体中才会有数据。
```

![image-20221021161523927](http://forupload.oss-cn-guangzhou.aliyuncs.com/img/image-20221021161523927.png)

### Http响应

```css
状态行
    包含协议以及协议的版本，状态码。
    1.xxx: 刚开始接收到数据。
    2.xxx: 已经接收到数据，可以解析数据。
    3.xxx: 重定向。
    4.xxx: 客户端的错误。
    5.xxx: 服务端错误。
    这些都是http的状态码，其实还要后台自己定义的错误码，和这里的状态码不一样。

响应报头
    Date: 接收到请求的日期时间。
    Content-Type: 响应的数据类型。
    Content-Length: 响应数据的内容长度。

响应报文
    常见的是返回了html网页内容，或者返回了json数据。
```

```css
状态码
    成功2×× 成功处理了请求的状态码。
      200 服务器已成功处理了请求并提供了请求的网页。
      204 服务器成功处理了请求，但没有返回任何内容。
    重定向3×× 每次请求中使用重定向不要超过 5 次。
      301 请求的网页已永久移动到新位置。
	  当URLs发生变化时，使用301代码。搜索引擎索引中保存新的URL。
      302 请求的网页临时移动到新位置。搜索引擎索引中保存原来的URL。
      304 如果网页自请求者上次请求后没有更新，则用304代码告诉搜索引擎机器人，可节省带宽和开销。
    客户端错误4×× 表示请求可能出错，妨碍了服务器的处理。
      400 服务器不理解请求的语法。
      403 服务器拒绝请求。
      404 服务器找不到请求的网页。服务器上不存在的网页经常会返回此代码。
      410 请求的资源永久删除后，服务器返回此响应。
		该代码与 404（未找到）代码相似，但在资源以前存在而现在不存在的情况下，
		有时用来替代404 代码。如果资源已永久删除，应当使用 301 指定资源的新位置。
    服务器错误5×× 表示服务器在处理请求时发生内部错误。
	这些错误可能是服务器本身的错误，而不是请求出错。
      500 服务器遇到错误，无法完成请求。
      503 服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。
```

![image-20221021161659130](http://forupload.oss-cn-guangzhou.aliyuncs.com/img/image-20221021161659130.png)

### 补充socket

```css
socket是套接字，是对TCP/IP的封装。它对数据传输的两者提供了一个全双工的管道。

socket和http一样，传输数据前要经历三次握手链接也要经历四次挥手断开链接。

socket和http协议的区别在于，socket是一个长链接，http1.0是短连接。
socket虽然是长链接，但是由于网络等原因也有可能会断开链接。
所以往往会提供一个心跳包，每隔一段时间向服务器发送一个规定好的心跳，
如果某一个时间发送没有收到心跳，那代表已经断开链接了。

这里又问了？Http1.1有长连接，那和socket的长连接有什么区别？
	http1.1长连接是为了多次请求服务器可以复用tcp通道，省去销毁和再建tcp通道的时间
	而socket的目的是为了客户端和服务器之间形成管道，保持两者都可以相互通讯。
```



## 4、浏览器缓存机制

### 浏览器缓存机制的两点关键

```js
1、浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识（假设没有）
/*  （注意: 是在浏览器的缓存中找请求的结果，这个时候tcp已经建立连接）
	在 tcp建立连接之前，要找到ip去三次握手，那里也有个缓存，如下：
	
	输入url后，浏览器开始智能匹配缓存中（比如历史记录、书签）的地址
	首先客户端检查本地是否有对应的IP地址，查看本地磁盘的hosts文件，看是否有对应的IP地址
	---> 没有，则浏览器会发送一个DNS请求到本地的DNS服务器
	（例如中国电信啊，移动啊，这些网络提供商提供的）
	本地的DNS服务器收到请求后，先查询它的缓存记录，缓存中有要找的记录，那么返回IP地址，
	如果没有要找的记录，那么本地DNS服务器会向根服务器进行查找（递归查询）
	根没有，就往域服务器(.com)上找，最后找到ip，本地服务器顺便保存这一域名和ip到缓存
	（如果到了域服务器上找，他只会返回的是另外的你所需要的域名解析的服务器地址，
	你需要再次请求，从新的服务器地址，拿到域名解析后的ip） */
向服务器发请求，服务器接受到请求，返回该请求结果和缓存规则
2、浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中
```



### 强制缓存

```css
强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的"缓存规则"来决定是否使用该缓存结果的过程
强制缓存的情况主要有三种
	1、不存在该缓存结果和缓存标识，"强制缓存失效"，向服务器发起Http请求（第一次请求就是这样的）
	2、存在该缓存结果和缓存标识，但该结果已失效，"强制缓存失效"，则使用"协商缓存"
	3、存在该缓存结果和缓存标识，且没过期，"强制缓存成功"。

说了那么多次"缓存规则"，到底是什么？ ---- 我个人理解为响应报文头内的几个字段
	当浏览器向服务器发起请求时，服务器会将缓存规则
	放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，
	控制强制缓存的字段分别是Expires和Cache-Control，
	其中Cache-Control优先级比Expires高。(同时存在时，只有Cache-Control生效)
```



### Expires

```css
Expires是HTTP/1.0控制网页缓存的字段
代表着："到期时间"，如果客户端的时间小于Expires的值时，直接使用缓存结果。

到了HTTP/1.1，Expire已经被Cache-Control替代，可是为什么？
	因为：Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，
	那么如果客户端与服务端的时间因为某些原因（例如：时区不同；客户/服务端有一方的时间不准确）
	发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义，
	而：
	Cache-Control的max-age（比如为600）是相对值，
	在600秒内再次发起该请求，则会直接使用缓存结果，强制缓存生效
	Expire: Mon,16 Apr 2018 01:41:50:GMT 是绝对值
	
```



### Cache-Control

```css
在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存

主要取值为：
    public："所有内容都将被缓存（客户端和代理服务器都可缓存）"
    private：所有内容"只有客户端可以缓存"，Cache-Control的"默认"取值
    no-cache：客户端缓存内容，但是 是否使用缓存则"需要经过协商缓存"来验证决定
    no-store：所有内容都不会被缓存，即: "既不使用强制缓存，也不使用协商缓存"
    max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效
```



### 缓存存放的位置

```css
我们以博客的请求为例，
	访问https://xxxx –> 200 –> 关闭博客的标签页 –> 重新打开 https://xxxx
	–> 200(from disk cache) –> 刷新 –> 200(from memory cache)

	状态码为灰色的请求则代表使用了强制缓存，
	请求对应的Size值,则代表该缓存存放的位置，(Size为数字表示是请求来的)
	分别为from memory cache 和 from disk cache
        from memory cache：代表使用内存中的缓存
        from disk cache：代表使用的是硬盘中的缓存
	( 浏览器读取缓存的顺序为：memory –> disk ------ 先内存后硬盘 )

补充：
	在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，
	那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；
	而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。
```

![image-20221021170631689](http://forupload.oss-cn-guangzhou.aliyuncs.com/img/image-20221021170631689.png)

### 协商缓存

```css
我们可以知道强缓存的3种中，其中一种失败了，会触发协商缓存（或者服务器设置了no-cache等字段）
	协商缓存生效，返回304，服务端资源无更新
	协商缓存失效，返回200和请求结果结果
对于协商缓存，也有对应的自己的字段：
	控制协商缓存的字段分别有：
	"Last-Modified / If-Modified-Since" 和 "Etag / If-None-Match"
	其中 Etag / If-None-Match 的优先级比 Last-Modified / If-Modified-Since "高"。
	（ 同时存在则只有Etag / If-None-Match生效 ）

字段含义：
	Last-Modified：（Response）
		服务器响应请求时，返回该资源文件在服务器最后被修改的时间
	If-Modified-Since：（Request）
		客户端再次发起该请求时，携带上次请求返回的Last-Modified值，
		通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。
		服务器收到该请求，发现请求头含有If-Modified-Since字段，
		则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，
		若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，
		状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件

	Etag：（Response）
		服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)
	If-None-Match：（Request）
		携带上次请求返回的唯一标识Etag值，
		通过此字段值告诉服务器该资源上次请求返回的唯一标识值。
		服务器收到该请求后，发现该请求头中含有If-None-Match，
		则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，
		一致则返回304，代表资源无更新，继续使用缓存文件；
		不一致则重新返回资源文件，状态码为200，

```

![image-20221021171850305](http://forupload.oss-cn-guangzhou.aliyuncs.com/img/image-20221021171850305.png)

```css
参考文章：
	https://juejin.cn/post/6844903593275817998#heading-1
其他文章：
	https://www.jianshu.com/p/fb59c770160c
```



